# Steps Leaderboard

A simple yet extensible application to track steps across multiple teams of employees. Each team can have one or more counters (users), and the app provides a REST API to manage teams, counters, and step increments.

---

## Table of Contents

1. [Overview](#overview)  
2. [Features](#features)  
3. [Architecture](#architecture)  
4. [API Endpoints](#api-endpoints)  
5. [Authentication & Authorization](#authentication--authorization)  
6. [Scaling & Fault Tolerance](#scaling--fault-tolerance)  

---

## Overview

The **Steps Leaderboard** application lets you:

- Create and manage teams.  
- Add counters (representing individual step counters for each team member).  
- Increment step values for any counter.  
- Fetch current total steps for a team, or list all counters in a team.  
- Compare multiple teams’ step counts to foster healthy competition.  

This project demonstrates **clean architecture principles**, such as:

- Separation of Concerns (Controller, Service, Repository).  
- SOLID and KISS design.  
- Dependency Injection.  
- In-memory data storage (easy to switch to a real database).  

---

## Features

1. **RESTful Endpoints**:  
   - CRUD operations for Teams and Counters.  
   - Increment counters to update step totals.  

2. **In-Memory Storage (default)**:  
   - Data persists for the lifetime of the application.  
   - Simple to replace with EF Core or another DB.  

3. **Optimistic Concurrency (optional)**:  
   - Version checks or concurrent collections for in-memory usage.  

4. **Asynchronous (Async/Await)**:  
   - Services and controllers use async patterns for future-proofing.  

5. **Extensible Architecture**:  
   - Swap out the repository for EF Core or NoSQL easily.  

---

## Architecture

The solution follows a layered approach:

- **Controllers**: Expose REST endpoints, handle HTTP requests/responses.  
- **Services**: Contain business logic (team creation, counter increments, validations).  
- **Repositories**: Handle data persistence (in-memory by default).  
- **Models**: Plain C# classes (`Team`, `Counter`) describing the domain.  

**[Client] --> [Controller] --> [Service] --> [Repository] --> [Data Storage]**


---

## API Endpoints

Below is a condensed list of the main endpoints (assuming a base URL of `/api`):

### Teams

- Create Team: `POST /api/teams`  
  `"name": "TeamName"`

- Get All Teams: `GET /api/teams`

- Get Team by Id: `GET /api/teams/{teamId}`

- Delete Team: `DELETE /api/teams/{teamId}`

- Get Team Total Steps: `GET /api/teams/{teamId}/totalSteps`

### Counters

- Create Counter: `POST /api/teams/{teamId}/counters`  
  `"ownerName": "UserName"`

- Get Counter by Id: `GET /api/counters/{counterId}`

- Increment Counter: `PATCH /api/counters/{counterId}/increment`  
  `"steps": 1500`

- List Counters for a Team: `GET /api/teams/{teamId}/counters`

- Delete Counter: `DELETE /api/counters/{counterId}`

You can explore or test these endpoints using **Swagger** at `/swagger`.

---

## Authentication & Authorization

The application is implemented to use **JWT-based authentication**, providing secure access control for the API. 

1. Users can authenticate via tokens generated by a secure signing mechanism.
2. Tokens must be included in the Authorization header for authenticated API requests.


---

## Scaling & Fault Tolerance

To scale from small to large usage:

- **Horizontal Scaling**:  
  Deploy multiple instances behind a load balancer (e.g., Azure App Service, AKS).  

- **Database**:  
  Migrate from in-memory to a SQL or NoSQL database.  

- **Caching**:  
  Introduce Redis for frequently accessed leaderboard queries.  

- **Message Queue (optional)**:  
  For high-throughput updates (e.g., Kafka, RabbitMQ).  

For high availability:

- Multi-region or availability zone deployments.  
- Health checks, auto-scaling, and monitoring.
